/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package adisuper94.ids.hashtable;

class IDSHashtable {
  private class Entry {
    public int flowId;
    public int count;

    public Entry(int flowId, int count) {
      this.flowId = flowId;
      this.count = count;
    }
  }

  private int n, k, c;
  private Entry[] entries;
  private int[] salts;

  public IDSHashtable(int n, int k, int c) {
    this.n = n;
    this.k = k;
    this.c = c;
    entries = new Entry[n];
    this.salts = new int[k];
    for (int i = 0; i < k; i++) {
      this.salts[i] = (int) (Math.random() * Integer.MAX_VALUE);
    }
  }

  /*
   * Returns
   * 1, if recording flow in existing entry
   * 0, if recording flow in a new entry
   * -1, if could not record
   */
  public int recordFlow(int flowId) {
    int[] hashes = this.multiHash(flowId);
    for (int hash : hashes) {
      int id = hash % this.n;
      if (this.entries[id] != null && this.entries[id].flowId == flowId) {
        this.entries[id].count++;
        return 1;
      }
    }
    for (int hash : hashes) {
      int id = hash % this.n;
      if (this.entries[id] == null) {
        Entry entry = new Entry(flowId, 1);
        this.entries[id] = entry;
        return 0;
      }
    }

    return this.cuckooRecord(new Entry(flowId, 1), this.c);
  }

  /**
   * Call this function only if record flow cannot happen.
   * 
   * @param entry
   * @param cuckooLevel
   * @return
   */
  private int cuckooRecord(Entry entry, int cuckooLevel) {
    if (cuckooLevel <= 0) {
      return -1;
    }
    int flowId = entry.flowId;
    int[] hashes = this.multiHash(flowId);
    for (int hash : hashes) {
      int id = hash % this.n;
      if (this.entries[id] != null) {
        Entry otherEntry = this.entries[id];
        if (this.move(otherEntry.flowId)) {
          this.entries[id] = entry;
          return 1;
        }
      } else {
        System.out.println("TSNH 2");
        return this.recordFlow(flowId);
      }
    }
    for (int hash : hashes) {
      int id = hash % this.n;
      if (this.entries[id] != null) {
        Entry otherEntry = this.entries[id];
        if (this.cuckooRecord(otherEntry, cuckooLevel - 1) >= 0) {
          this.entries[id] = null;
          return this.cuckooRecord(entry, cuckooLevel - 1);
        }
      } else {
        System.out.println("TSNH 1");
        return this.recordFlow(flowId);
      }
    }
    return -2;
  }

  private boolean move(int flowId) {
    int[] hashes = this.multiHash(flowId);
    for (int hash : hashes) {
      int id = hash % this.n;
      Entry entry = this.entries[id];
      if (entry != null && entry.flowId == flowId) {
        int currentId = id;
        for (int hash2 : hashes) {
          int nextId = hash2 % this.n;
          if (this.entries[nextId] == null) {
            this.entries[nextId] = entry;
            this.entries[currentId] = null;
            return true;
          }
        }
      }

    }
    return false;
  }

  /**
   * Returns count if found, else 0.
   */
  public int getCount(int flowId) {
    int[] hashes = this.multiHash(flowId);
    for (int hash : hashes) {
      int id = hash % this.n;
      if (this.entries[id] != null && this.entries[id].flowId == flowId) {
        return this.entries[id].count++;
      }
    }
    return 0;
  }

  private int[] multiHash(int flowId) {
    int masterHash = Integer.hashCode(flowId);
    int[] hashes = new int[this.k];
    for (int i = 0; i < k; i++) {
      hashes[i] = masterHash ^ this.salts[i];
    }
    return hashes;
  }

}
